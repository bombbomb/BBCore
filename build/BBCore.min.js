/*! BBCore 2020-11-5 */
/*
 BombBomb's App Core API JS Implementation
 Copyright 2013-2016 BombBomb, Inc.
 Version 2.0
 */

/**
 * @typedef {Object} responseSuccess
 * @prop {string} status
 * @prop {string} method
 * @prop {Object} info
 */

/**
 * @typedef {Object} responseObject
 * @prop {string} status
 * @prop {string} method
 * @prop {Object} info
 */

/**
 * @typedef {Object} OAuthClientCredentials
 * @prop {string} clientIdentifier
 * @prop {string} clientSecret
 * @prop {string} redirectUri
 * @prop {string} type 'implicit' | 'authorization_code'
 */

/**
 @class
 @prop {string} userEmail
 @prop {string} userId
 @prop {string} clientId
 @prop {string} accessToken
 @prop {string} currentVideoId
 @prop {string} email
 @prop {string} onerror

 @constructs BBCore
 @param {Object} options
 @param {string} options.userEmail
 @param {string} options.userId
 @param {string} options.clientId
 @param {string} options.accessToken
 @param {string} options.currentVideoId
 @param {string} options.email
 @param {string} options.onerror
 @param {OAuthClientCredentials} options.credentials
 */

 // polyfill for Object.create.
 if (typeof Object.create !== "function") {
    Object.create = function (proto, propertiesObject) {
        if (typeof proto !== 'object' && typeof proto !== 'function') {
            throw new TypeError('Object prototype may only be an Object: ' + proto);
        } else if (proto === null) {
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
        }
         if (typeof propertiesObject != 'undefined') {
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");
        }
         function F() {}
        F.prototype = proto;
         return new F();
    };
}

function BBCore(options) {
    this.userEmail = "";
    this.userId = "";
    this.clientId = "";
    this.accessToken = "";
    this.currentVideoId = null;
    this.email = null;
    this.apiServer = null;
    this.credentials = { clientIdentifier: null, redirectUri: null, clientSecret: null, type: 'implicit' };
    this.onerror = null;

    this.__mergeProperties(null, options);

    // private properties
    this.authenticated = false;
    this.hasContext = false;
    this.storage = localStorage || window.storage;
    this.CONTENT = {QUICKSEND: ''};
    this.lastresponse = "";
    this.__vidRecording = false;
    this.__vidRecHndl = null;

    /** @class */
    this.contacts = function () {};
    this.contacts.prototype = Object.create(Array.prototype);
    this.contacts.constructor = this.contacts;
    /**
     * Adds a Contact {@link BBCore.contact} to Contacts collection
     * @param {contact} contact
     * @returns {contacts}
     */
    this.contacts.prototype.add = function (contact) {
        this.push(contact);
        return this;
    };
    /**
     * Returns the first matched contact from
     * @param {string} fieldName - Name of the field to search for the value
     * @param {string} value - Value to search for in the contacts
     * @returns {*|BBCore.contact}
     */
    this.contacts.prototype.find = function (fieldName, value) {
        for (var contact in this) {
            if (this.hasOwnProperty(contact) && contact[fieldName] === value) {
                return contact;
            }
        }
        return null;
    };
    this.contacts.prototype.get = function (contactId) {
        return this.find('id', contactId);
    };

    /**
     * @namespace BBCore.video
     * @class {Object} BBCore.videos
     */
    this.videos = function () {
    };
    this.videos.prototype = Object.create(Array.prototype);
    this.videos.constructor = this.videos;
    /**
     * Adds a Video to the collection
     * @param {video} video
     * @returns {videos}
     */
    this.videos.prototype.add = function (video) {
        this.push(video);
        return this;
    };

    // run initial methods
    if (this.accessToken) {
        this.validateAccessToken();
    }
    if (this.email && this.password) {
        this.login(this.email, this.password);
    }

}

/**
 @typedef {Object} BBCore.CONFIG
 @prop VERSION
 @prop API_END_POINT
 @prop SERVER_API_URL
 @constant
 */
BBCore.CONFIG =
{
    VERSION: "1.0",
    API_END_POINT: "/app/api/api.php",
    SERVER_API_URL: "https://app.bombbomb.com",
    OAUTH_STORAGE: 'authToken'
};

BBCore.prototype.__mergeProperties = function (base, addl) {
    if (!base)
    {
        base = this;
    }
    for (var prop in addl)
    {
        if (prop && addl.hasOwnProperty(prop))
        {
            base[prop] = (base[prop] && typeof base[prop] === 'object') ? this.__mergeProperties(base[prop],addl[prop]) : addl[prop];
        }
    }
    return base;
};

BBCore.prototype.onError = function (func_or_deet, xhr) {
    if (typeof func_or_deet === "function") {
        this.onerror = func_or_deet;
    } else {
        if (this.onerror) {
            this.onerror.call(this, func_or_deet, xhr);
        }
    }
};

BBCore.prototype.ver = function () {
    return BBCore.CONFIG.VERSION;
};


/** @class BBCore */

/**
 * This callback is displayed as a global member.
 * @callback responseSuccess
 * @param {Object} responseObject
 * @param {Object} [jqXHR]
 */

/**
 *
 * @returns {BBCore.apiServer|*|BBCore.CONFIG.SERVER_API_URL}
 */
BBCore.prototype.getServerUrl = function () {
    return this.apiServer || BBCore.CONFIG.SERVER_API_URL;
};

/**
 * Returns the fully qualified URL for BB API
 * @returns {string}
 */
BBCore.prototype.getRequestUrl = function () {
    return this.getServerUrl() + BBCore.CONFIG.API_END_POINT;
};

/**
 * @typedef {object} requestParameters
 * @prop {string} [method]
 * @prop {string} [api_key]
 * @prop {string} [async]
 * @prop {string} [url]
 * @prop {string} [url]
 */

 BBCore._addParameterToUrl = function (urlString, parameterKey, parameterValue) {
    var separator = '?';
    if(urlString.indexOf('?') !== -1) {
        separator = '&'
    }
    return urlString + separator + parameterKey + "=" + parameterValue;
 }

/**
 * Sends a request to the specified method of the [BombBomb API](//bombbomb.com/api)
 * @arg {string}                        method The method name to call
 * @arg {requestParameters} [params]    The parameters to send with the request
 * @arg {responseSuccess}   [success]   A callback when the request succeeds
 * @arg {responseSuccess}   [error]     A callback when the request fails
 */
BBCore.prototype.sendRequest = function (method, params, success, error) {
    if (typeof params === "function") {
        success = params;
    }
    if (typeof method === "object") {
        params = method;
    }
    if (typeof method === "object" && params.method) {
        method = params.method;
    }

    if (typeof method === 'string' && !params.method) {
        params.method = method;
    }

    if (method !== "IsValidLogin" && !params.api_key) {
        params.api_key = this.getKey();
    }
    if ((method !== "ValidateSession" && params.grant_type !== "authorization_code") && !this.authenticated) {
        this.onError.call(this, {
            status: 'failure',
            methodName: 'InvalidSession',
            info: { errormsg: 'Invalid login' }
        }, null);
        return false;
    }

    var requestHeaders = {};
    var inst = this;
    var asyncSetting = true;
    if (typeof params.async !== 'undefined') {
        asyncSetting = params.async;
    }

    var requestToken = this.getOAuthTokenForRequest();
    if (requestToken && requestToken.length)
    {
        requestHeaders['Authorization'] = requestToken;
        typeof params.api_key !== 'undefined' && delete params.api_key
    }
    else if(this.isAccessToken(params.api_key)) {
        requestHeaders['Authorization'] = params.api_key;
        delete params.api_key;
    }
    var url = params.url ? params.url : this.getRequestUrl();
    url = BBCore._addParameterToUrl(url, 'xsrc', 'bbcore-' + BBCore.CONFIG.VERSION);

    let formData = new FormData();
    Object.keys(params).forEach(key => {
      formData.append(key, params[key])
    })

    const xhr = new XMLHttpRequest();
    xhr.open('POST', url, asyncSetting)
    Object.keys(requestHeaders).forEach(headerKey => {
      xhr.setRequestHeader(headerKey, requestHeaders[headerKey]);
    })

    xhr.onload = (result) => {
      const res = JSON.parse(result.target.response);
      if(xhr.readyState === 4 && xhr.status === 200) {
        if (res.status === "success") {
            // if the result returned a
            if (method === "GetVideoGuid" && res.info && res.info.video_id) {
                inst.currentVideoId = res.info.video_id;
            }
            if (success) {
                success.call(inst, res);
            }
        } else if ((params.grant_type === "authorization_code" || params.grant_type === "refresh_token")) {
            success.call(inst, res);
        } else {
            inst.onError.call(inst, res);
        }
      } else {
        // non-200 status code
        inst.onError.call(inst, res);
      }
    };
    
    xhr.onerror = (jqXHR)  => {
      let resp = {
        status: 'unknown',
        jqXHR: jqXHR,
      };
      if (typeof jqXHR.responseJSON !== 'undefined') {
        resp = jqXHR.responseJSON;
      }
      inst.lastresponse = resp.status;
      if ("success" === resp.status) {
        success.call(inst, resp, jqXHR);
      } else {
        inst.onError.call(inst, resp, jqXHR);
      }

      if (error) {
        error(inst, resp);
      }
    };

    xhr.send(formData)

};

/**
 * Authenticates a user using their Email Address (User Id) and Password
 * @arg {string} uid
 * @arg {string} pwd
 * @arg {responseSuccess} success
 */
BBCore.prototype.login = function (uid, pwd, success) {
    if (arguments.length < 2 && (this.credentials && this.credentials.clientIdentifier))
    {
        var locationTarget = window;
        if (typeof usePopup !== 'undefined')
        {
            locationTarget = window.open("about:blank", "_blank");
        }
        locationTarget.location = this.getOAuthUrl();
    }
    else
    {
        if (typeof uid === "function") {
            success = uid;
            uid = this.storage.getItem('b2-uid');
            pwd = this.storage.getItem('b2-pwd');
        }

        if (!uid && !this.accessToken) {
            this.onError({ info: { errormsg: 'Username cannot be blank' } });
            return;
        }

        this.userEmail = uid;

        var inst = this;
        this.sendRequest({method: "ValidateSession", email: uid, pw: pwd, jwt: true}, function (respObj) {
            inst.__updateSession(respObj, success);
        });
    }
};

BBCore.prototype.logout = function () {
    this.clearJsonWebToken();
    this.clearOAuthToken();
    this.clearKey();
    this.storage.removeItem('b2-uid');
    this.storage.removeItem('b2-pwd');
    this.accessToken = '';
    this.hasContext = false;
    this.authenticated = false;
};

/**
 * Returns bool for whether or not a prior authentication is stored locally
 * @returns {boolean}
 */
BBCore.prototype.credentialsSaved = function () {
    return null !== this.storage.getItem("b2-uid") || null !== this.storage.getItem("access_token") || null !== this.storage.getItem("jsonWebToken") || null !== localStorage.getItem("authToken");
};

/**
 * Save credentials to local storage (not recommended)
 * @arg {string} uid - User ID/Email Address
 * @arg {string} pwd - Password
 */
BBCore.prototype.saveCredentials = function (uid, pwd) {
    this.storage.setItem("b2-uid", uid);
};

/**
 * Authenticates from previously stored credentials
 * @arg {responseSuccess} onSuccess
 * @arg {responseSuccess} onError
 */
BBCore.prototype.validateSession = function (onSuccess, onError) {

    var oAuthPayload = this.getOAuthPayload();
    var inst = this;
    var authCode = /[\?\#].*&*(access_token|code)=([^&]+)/gi.exec(window.location);
    if (authCode && authCode.length > 1)
    {
        var tokenOrCode = authCode[2];
        if (authCode[1] === 'code')
        {
            this.validateOAuthCode(decodeURIComponent(tokenOrCode), function(payload){
                this.storeOAuthTokens(payload);
                window.location.href = authCode[0].substr(0,5) === '?code' ? window.location.href.replace('?code='+tokenOrCode,'') : window.location.href.replace('&code='+authCode[1],'');
            }, onError);
        }
        else
        {
            var authPayload = { access_token: tokenOrCode, token_type: null, expires_in: null },
                cleanedHash = window.location.hash.replace('access_token='+tokenOrCode,''),
                hashKeyMatches = null;
            while (hashKeyMatches = /\&*(token_type|expires_in)=([^&]+)/gi.exec(window.location.hash))
            {
                authPayload[hashKeyMatches[1]] = hashKeyMatches[2];
                cleanedHash = cleanedHash.replace(hashKeyMatches[0],'');
                window.location.hash = cleanedHash.length > 1 ? cleanedHash : '';
            }
            this.authenticated = true;
            this.storeOAuthTokens(authPayload);
            onSuccess.call(inst);
        }
    }
    else if (this.isOAuthTokenValid(oAuthPayload))
    {
        var jwtPayload = this.__getOAuthAccessPayload(oAuthPayload);
        this.__updateSession({ status: "success", info: { clientId: jwtPayload.bbcid, userId: jwtPayload.sub } },function(){
            onSuccess.call(inst);
        });
    }
    else if (!this.getKey() && this.getJsonWebToken())
    {
        this.verifyJsonWebToken(function(response){
            inst.__updateSession(response);
            onSuccess.call(inst,response);
        });
    }
    else
    {
        if (this.credentials && this.credentials.clientIdentifier) {
            if (onError) onError(); // use error callback to signal OAuth login is require
        }
        else if (this.getKey()) {
            this.validateAccessToken(onSuccess);
        }
        else if (this.storage.getItem("b2-uid")) {
            this.login(onSuccess);
        }
        else {
            if (onError) onError();
        }
    }
};

BBCore.prototype.getOAuthUrl = function()
{
    var url = null,
        oAuthCreds = this.credentials;
    if (oAuthCreds.clientIdentifier && oAuthCreds.redirectUri)
    {
        url = this.getServerUrl()+"/auth/authorize?"
            +"client_id="+oAuthCreds.clientIdentifier
            +"&scope="+encodeURIComponent(oAuthCreds.scope ? oAuthCreds.scope : 'all:manage')
            +"&redirect_uri="+encodeURIComponent(oAuthCreds.redirectUri)
            +"&response_type=" + (oAuthCreds.type === 'implicit' ? "token" : "code");
    }
    return url;

};

/**
 * DEPRECATED - Use validateSession
 */
BBCore.prototype.resumeStoredSession = BBCore.prototype.validateSession;

/**
 *
 * @param onSuccess
 */
BBCore.prototype.validateAccessToken = function (onSuccess) {
    var inst = this;
    this.sendRequest({method: "ValidateSession",api_key: this.accessToken,async: false,jwt: true},function (respObj) {
        inst.__updateSession(respObj, onSuccess);
    });
};

/**
 * Detects if accessToken provided is an api_key or an accessToken
 */
BBCore.prototype.isAccessToken = function (value) {
    return typeof value === 'string' && value.length > 32 && value.indexOf('.') > -1;
}

/**
 * Returns bool for authentication state
 * @returns {boolean|*}
 */
BBCore.prototype.isAuthenticated = function () {
    if (!this.authenticated) {
        console.log('You must authenticate a BombBomb session before making additional calls.');
    }
    return this.authenticated;
};

/**
 * Invalidates and clears the active session, similar to logout
 * @returns {boolean|*}
 */
BBCore.prototype.invalidateSession = function()
{
    try
    {
        this.logout();
    }
    catch (e)
    {
        return false;
    }
    return true;
};

BBCore.prototype.__updateSession = function (respObj, done) {
    if (respObj.status === "success") {
        if (respObj.info.userId)
        {
            this.userId = respObj.info.userId;
            this.clientId = respObj.info.clientId;
        }
        else
        {
            this.userId = respObj.info.user_id;
            this.clientId = respObj.info.client_id;
        }

        if (respObj.info.api_key)
        {
            this.accessToken = respObj.info.api_key;
        }

        this.hasContext = true;
        this.authenticated = true;

        this.storeKey(this.accessToken);
        this.storeJsonWebToken(respObj.info.jwtoken);

        console.log('bbcore: __updateSession session updated.');

        if (done) {
            done.call(this, respObj);
        }
    }
};


/**
 * Validates the given key
 * @arg {string} key
 * @arg {responseSuccess} complete
 */
BBCore.prototype.verifyKey = function (key, complete) {
    // TODO; should ValidateSession replace this or vise-versa
    this.sendRequest({method: "GetEmails", api_key: key}, function (resp) {
        if (complete) {
            complete({isValid: (resp.status === "success")});
        }
    });
};

/**
 * Stores the give session key, typically used so a session can be resumed later on.
 * @arg key
 */
BBCore.prototype.storeKey = function (key) {
    if (!key)
    {
        return;
    }

    // currently this will use the API Key, in the future this should be updated to use a key which can be expired
    this.accessToken = key;
    this.storage.setItem("access_token", this.accessToken);
};

BBCore.prototype.getKey = function () {
    return this.accessToken ? this.accessToken : this.storage.getItem("access_token");
};
BBCore.prototype.clearKey = function () {
    this.accessToken = null;
    this.storage.removeItem('access_token');
};


/**
 * Validates the given key
 * @arg {string} key
 * @arg {responseSuccess} complete
 */
BBCore.prototype.verifyJsonWebToken = function (key, complete) {
    if (typeof key == 'function')
    {
        complete = key;
        key = this.getJsonWebToken();
    }
    this.sendRequest({method: "ValidateJsonWebToken", jwt: key}, function (resp) {
        if (complete)
        {
            resp.isValid = (resp.status === "success");
            complete(resp);
        }
    });
};

/**
 * Stores the OAuth Token for API calls
 * @arg key
 */
BBCore.prototype.storeOAuthTokens = function(oAuthPayload) {
    if (!oAuthPayload)
    {
        return;
    }
    try
    {
        oAuthPayload = typeof oAuthPayload === 'string' ? oAuthPayload : JSON.stringify(oAuthPayload);
        this.storage.setItem(BBCore.CONFIG.OAUTH_STORAGE, btoa(oAuthPayload));
    }
    catch (e)
    {
    }
};

/**
 *
 * @returns {string}
 */
BBCore.prototype.getOAuthPayload = function()
{
    var storagePayload = this.storage.getItem(BBCore.CONFIG.OAUTH_STORAGE);
    return storagePayload ? atob(storagePayload) : null;
};

BBCore.prototype.getOAuthTokenForRequest = function() {
    var token = null;
    try
    {
        var storagePayload = this.getOAuthPayload();
        if (storagePayload && this.isOAuthTokenValid(storagePayload))
        {
            var parsedPayload = JSON.parse(storagePayload);
            if (typeof parsedPayload === 'object')
            {
                token = parsedPayload.token_type.substr(0,1).toUpperCase()+parsedPayload.token_type.substr(1) + ' ' + parsedPayload.access_token;
            }
        }
    }
    catch (e)
    {
        console.error("Exception occurred retrieving OAuth Token for Request",e);
    }
    return token;
};

BBCore.prototype.clearOAuthToken = function () {
    this.authenticated = false;
    this.storage.removeItem(BBCore.CONFIG.OAUTH_STORAGE);
};

BBCore.prototype.__getOAuthAccessPayload = function(payload) {
    var jsonPayload = typeof payload === 'string' ? JSON.parse(payload) : payload,
        jwtObj = null;
    if (jsonPayload)
    {
        try
        {
            var jwtParts = jsonPayload.access_token.split('.');
            if (jwtParts.length > 2)
            {
                jwtObj = JSON.parse(atob(jwtParts[1]));
            }
        }
        catch (e)
        {
            console.warn('Exception __getOAuthAccessPayload fetching access_token payload',e);
        }
    }
    return jwtObj;
};

BBCore.prototype.isOAuthTokenValid = function(payload) {

    var isValid = false;
    try
    {
        var jwtObj = this.__getOAuthAccessPayload(payload);
        if (jwtObj && (new Date(jwtObj.exp)) < Date.now())
        {
            isValid = true;
        }
    }
    catch (e)
    {
        console.warn('Exception while validating OAuthToken',e);
    }
    return isValid;

};

/**
 *
 * @param authCode
 * @param onSuccess
 * @param onError
 */
BBCore.prototype.validateOAuthCode = function(authCode, onSuccess, onError) {

    var inst = this,
        credentials = this.credentials,
        authRequestPayload = {
            url: this.getServerUrl() + '/auth/access_token',
            grant_type: credentials.type || 'implicit',
            client_id: credentials.clientIdentifier,
            redirect_uri: credentials.redirectUri,
            code: JSON.stringify(authCode)
        };
    if (credentials.type !== 'implicit')
    {
        if (credentials.clientSecret && credentials.clientSecret)
        {
            authRequestPayload.client_secret = credentials.clientSecret;
        }
        else
        {
            var warningMessage = 'Client Secret required when making '+credentials.type+' grant requests';
            console.warn(warningMessage);
            onError.call(this,warningMessage);
            return;
        }
    }
    this.sendRequest(authRequestPayload, function(resp) {
        if (resp && this.isOAuthTokenValid(resp))
        {
            this.authenticated = true;
            this.storeOAuthTokens(resp);
            onSuccess && onSuccess.call(inst);
        }
        else
        {
            onError && onError.call(inst);
        }
    });
};

/**
 *
 */
BBCore.prototype.refreshOAuthToken = function(onSuccess) {

    var credentials = this.credentials,
        refreshRequestPayload = {
            url: this.getServerUrl() + '/auth/access_token',
            grant_type: 'refresh_token',
            refresh_token: this.getOAuthRefreshToken(),
            client_id: credentials.clientIdentifier,
            client_secret: credentials.clientSecret,
            redirect_uri: credentials.redirectUri,
            code: JSON.stringify(authCode)
        };
    this.sendRequest(refreshRequestPayload, function(resp) {
        console.log('got refresh auth back',resp);
        if (resp)
        {
            if (this.isOAuthTokenValid(resp))
            {
                this.authenticated = true;
            }
            this.storeOAuthTokens(resp);
            onSuccess && onSuccess();
        }
    });
};

/**
 * Stores the give session key, typically used so a session can be resumed later on.
 * @arg key
 */
BBCore.prototype.storeJsonWebToken = function (token) {
    if (!token)
    {
        return;
    }
    this.jsonWebToken = token;
    this.storage.setItem("jsonWebToken", this.jsonWebToken);
};

BBCore.prototype.getJsonWebToken = function () {
    return this.jsonWebToken ? this.jsonWebToken : this.storage.getItem("jsonWebToken");
};
BBCore.prototype.clearJsonWebToken = function () {
    this.jsonWebToken = null;
    this.storage.removeItem('jsonWebToken');
};

/**
 * Attempts to always return a valid JWT which makes an async verification request
 * @param callback - handler given a valid JWT.  If the JWT is null then the user
 * is NOT authenticated.
 */
BBCore.prototype.getValidJsonWebTokenAsync = function(callback) {
    var currentToken = this.getJsonWebToken();
    if (!currentToken && callback) {
        callback(null);
        return;
    }

    this.verifyJsonWebToken(currentToken, function(response) {
        if (response && response.isValid) {
            if (callback) {
                callback(currentToken);
            }
        }
        else {
            this.validateAccessToken(function(responseObj) {
                if (callback) {
                    if (response) {
                        this.storeJsonWebToken(responseObj.jwtoken);
                        callback(this.getJsonWebToken());
                    }
                    else {
                        callback(null);
                    }
                }
            });
        }
    });
};

/**
 * Retrieves Contact Lists
 * @arg {responseSuccess}   success
 */
BBCore.prototype.getLists = function (success) {
    this.sendRequest({method: "GetLists"}, success);
};

/**
 * Creates a Contact List and returns the Guid
 * @arg {string}            listName
 * @arg {responseSuccess}   success
 */
BBCore.prototype.createList = function (listName, success) {
    this.sendRequest({method: "createList", name: listName}, success);
};

/**
 * Retrieves a Contact
 * @arg {string}          contactId
 * @arg {responseSuccess} success
 */
BBCore.prototype.getContact = function (contactId, success) {
    if (!contactId) {
        return;
    }
    var defaults = {width: 340, force_ssl: false};
    var parameters = {
      ...defaults,
      contact_id: contactId,
      method: 'GetContact',
    };
    this.sendRequest(parameters, success);
};

/**
 * Retrieves Contacts from a Contact List
 * @arg {string}          listId
 * @arg {responseSuccess} success
 */
BBCore.prototype.getListContacts = function (listId, success) {
    if (!listId) {
        return;
    }
    this.sendRequest({method: "GetListContacts", list_id: listId}, success);
};

/**
 * Adds a Contact to a Contact List
 * @arg {contact}         contact
 * @arg {responseSuccess} success
 */
BBCore.prototype.addContact = function (contact, success) {
    if (typeof contact === "object") {
        //combine the contact object into a request object
        contact.method = "AddContact";
        this.sendRequest(contact, success);
    }
};

/**
 * Adds a batch of Contacts
 * @arg {object}          opts
 * @arg {responseSuccess} success
 */
BBCore.prototype.bulkAddContacts = function (opts, success) {
    if (!opts) {
        opts = {};
    }
    opts.method = "BulkAddContacts";
    if (typeof opts.contacts === "object") {
        opts.contacts = JSON.stringify(opts.contacts);
    }

    this.sendRequest(opts, success);
};

/**
 *
 * @arg {object} opts
 * @arg {responseSuccess} success
 */
BBCore.prototype.updateContact = function (opts, success) {
    if (!opts) {
        return;
    }

    opts.method = "UpdateContact";
    this.sendRequest(opts, success);
};

/**
 * Retrieves an Import Address by a Type
 * @param opts
 * @param {responseSuccess} success
 */
BBCore.prototype.getImportAddressesByType = function (opts, success) {
    opts = {
      ...opts,
      method: 'getImportAddressesByType',
    };
    if (!opts.type) {
        this.onError({info: {errmsg: ['A Type must be provided.']}});
    }
    this.sendRequest(opts, success);
};

/**
 * Retrieves an Import Address by a Type
 * @param {object} opts
 * @param {responseSuccess} success
 */
BBCore.prototype.addContactImportAddress = function (opts, success) {
    opts = {
      opts,
      method: 'addContactImportAddress'
    };
    if (!opts.importAddrCode || !opts.importAddrName) {
        this.onError({info: {errmsg: ['An Import Address Code and Import Address Name must be provided.']}});
    }
    this.sendRequest(opts, success);
};

BBCore.prototype.deleteContactImportAddress = function (opts, success) {
    opts = {
      ...opts,
      importAddrCode: 1,
      method: 'deleteContactImportAddress',
    };
    if (!opts.importAddrCode) {
        this.onError({info: {errmsg: ['Invalid Import Address Code']}});
    }
    this.sendRequest(opts, success);
};

/**
 * Retrieves a list of Emails from the current authenticated session
 * @arg {responseSuccess}   success
 */
BBCore.prototype.getEmails = function (success) {
    this.sendRequest({ method: "GetEmails" }, success);
};

/**
 * @typedef {object} customVideoEmailOptions
 * @prop {string} from_name
 * @prop {string} email_id
 * @prop {string} email
 * @prop {string} subject
 * @prop {string} html_content
 */

/**
 *
 * @arg {customVideoEmailOptions} opts
 * @arg {Function} success
 */
BBCore.prototype.sendCustomVideoEmail = function (opts, success) {
    var defaults = {method: 'SendCustomVideoEmail', html_content: null, subject: '', email: '', email_id: '', from_name: ''};
    var parameters = { ...defaults, ...opts };
    this.sendRequest(parameters, success);
};

/**
 *
 * @arg {object} opts
 * @arg {responseSuccess} success
 */
BBCore.prototype.getDrips = function (opts, success) {
    opts = opts || {};
    opts.method = "GetDrips";
    this.sendRequest(opts, success);
};

/**
 *
 * @arg {object} opts
 * @arg {responseSuccess} success
 */
BBCore.prototype.getForms = function (opts, success) {
    // implement this
    opts = opts || {};
    opts.method = "GetForms";
    // need to extend the getForms to the api end-point
    this.sendRequest(opts, success);
};

/**
 *
 * @param opts
 * @param success
 */
BBCore.prototype.getClientIntegrations = function (opts, success) {
    if (typeof opts === 'function')
    {
        success = opts;
        opts = {};
    }
    opts.method = 'getClientIntegrations';
    this.sendRequest(opts, success);
};

/**
 * This callback is displayed as a global member.
 * @callback responseSuccess
 * @param {Object} responseObject
 * @param {Object} [jqXHR]
 */

/**
 * reponseSuccess
 * @param responseObject
 * @param jqXHR
 */
function responseSuccess(responseObject,jqXHR){}

/** @namespace BBCore */

/**
 * @typedef {Object} contactProperties
 * @prop {string} email     Email Address
 * @prop {string} firstname First Name
 * @prop {string} lastname  Last Name
 * @prop {string} phone_number  Phone Number
 * @prop {string} address_line_1  Address 1
 * @prop {string} address_line_2  Address 2
 * @prop {string} city      City
 * @prop {string} state     State
 * @prop {string} country   Country`
 * @prop {string} postal_code  Postal Code
 * @prop {string} company   Company
 * @prop {string} position  Position
 * @prop {string} comments  Comments
 * @prop {string} listlist  Array of List Ids the Contact is subscribed to
 * @prop {string} id        Contact Id
 */

/**
 * Contact Object
 * @class BBCore.contact
 * @classdesc stuff
 * @property {string} email     Email Address
 * @property {string} firstname First Name
 * @property {string} lastname  Last Name
 * @property {string} phone_number  Phone Number
 * @property {string} address_line_1  Address 1
 * @property {string} address_line_2  Address 2
 * @property {string} city      City
 * @property {string} state     State
 * @property {string} country   Country`
 * @property {string} postal_code  Postal Code
 * @property {string} company   Company
 * @property {string} position  Position
 * @property {string} comments  Comments
 * @property {string} listlist  Array of List Ids the Contact is subscribed to
 * @property {string} id        Contact Id
 * @param {contactProperties} properties - {@link contactProperties}
 */
BBCore.contact = function (properties) {
    this.email = "";
    this.firstname = "";
    this.lastname = "";
    this.phone = "";
    this.phone_number = "";
    this.address_line_1 = "";
    this.address_line_2 = "";
    this.city = "";
    this.state = "";
    this.country = "";
    this.postal_code = "";
    this.company = "";
    this.position = "";
    this.comments = "";
    this.listlist = "";
    this.id = "";
    for (var prop in properties) {
        if (properties.hasOwnProperty(prop)) {
            this[prop] = properties[prop];
        }
    }
    this.eml = this.email;
};


/**
 * @typedef {object} videoProperties
 * @prop {string} vid_id
 * @prop {string} title
 * @prop {string} filename
 */


/**
 * @namespace BBCore.video
 * @class BBCore.video
 * @prop {string} vid_id
 * @prop {string} title
 * @prop {string} filename
 * @constructs
 * @param {videoProperties} properties
 */
BBCore.video = function (properties) {
    this.vid_id = "";
    this.title = "";
    this.filename = "";

    for (var prop in properties) {
        if (properties.hasOwnProperty(prop)) {
            this[prop] = properties[prop];
        }
    }

};



BBCore.prototype.getVideoDeliveryUrl = function (opts) {
    opts = {
      video_id: '',
      autoplay: 1,
      ...opts,
    };
    var sPrefix = (this.getServerUrl().indexOf('dev') > 0 ? 'dev.' : (this.getServerUrl().indexOf('local') > 0 ? 'local.' : ''));
    return 'http://' + sPrefix + 'bbemaildelivery.com/bbext/?p=video_land&id=' + opts.video_id + '&autoplay=' + opts.autoplay;
};

BBCore.prototype.getVideo = function (vidId, success) {
    if (!vidId) {
        return;
    }
    this.sendRequest({method: "GetVideos", video_id: vidId}, success);
};

BBCore.prototype.getVideos = function (options, success) {
    var defaults = {
        updatedSince: '',
        page: null,
        pageSize: 50
    };
    if (typeof options === "function") {
        success = options;
        options = {};
    }
    var parameters = { ...defaults, ...options };

    if (typeof parameters === "object" && parameters != null) {
        if (parameters.pageSize !== undefined) {
            if (parameters.pageSize == null || parameters.pageSize <= 0 || isNaN(parameters.pageSize)) {
                return false;
            }
        }
    }

    // TODO: Can we get away with just using GetVideosPaged?
    parameters.method = "GetVideos";
    if (parameters.page !== null && parameters.pageSize) {
        parameters.method = "GetVideosPaged";
    }
    this.sendRequest(parameters, success);
};

BBCore.prototype.getVideoStatus = function (vidId, success) {
    if (!vidId) {
        return;
    }
    this.sendRequest({method: "getVideoStatus", id: vidId}, success);
};

BBCore.prototype.getEncodingReport = function (vidId, success) {
    if (!vidId) {
        return;
    }
    this.sendRequest({method: "getEncodingReport", id: vidId}, success);
};

/**
 * Deletes a Video
 * @arg {string}            videoId
 * @arg {responseSuccess}   success
 */
BBCore.prototype.deleteVideo = function (videoId, success) {
    this.sendRequest({method: "DeleteVideo", video_id: videoId}, success);
};


BBCore.prototype.setVideoId = function (vid_id) {
    this.currentVideoId = vid_id;
};

BBCore.prototype.getVideoId = function (pcall) {
    if (!this.currentVideoId) {
        this.getNewVideoGuid(pcall);
    } else if (pcall) {
        pcall.call(this, this.currentVideoId);
    }
};

BBCore.prototype.hasVideoId = function () {
    return !!this.currentVideoId;
};

BBCore.prototype.getNewVideoGuid = function (pcall) {
    var inst = this;
    this.sendRequest({method: "GetVideoGuid"}, function (data) {
        inst.currentVideoId = data.info.video_id;
        if (pcall) {
            pcall.call(this, inst.currentVideoId);
        }
    });
};


/**
 *
 * @param {object} opts
 * @param {responseSuccess} onSuccess
 */
BBCore.prototype.videoQuickSend = function (opts, onSuccess) {
    // TODO; this should be calling the api
    var reqDetails = {
            method: 'VideoQuickSend',
            subject: 'QuickSend from BombBomb',
            mobile_message: '',
            email_address: null,
            videoId: null
        },
        sendErrors = [];

    for (var op in reqDetails) {
        if (reqDetails.hasOwnProperty(op)) {
            if (!opts[op]) {
                opts[op] = reqDetails[op];
            }
        }
    }

    if (opts.message && !opts.mobile_message) {
        opts.mobile_message = opts.message;
    }
    if (opts.email && !opts.email_address) {
        opts.email_address = opts.email;
    }
    if (opts.email_address && !opts.email_addresses) {
        opts.email_addresses = opts.email_address;
    }
    if (!opts.video_id && this.currentVideoId) {
        opts.video_id = this.currentVideoId;
        opts.videoId = this.currentVideoId;
    }

    // check options
    if (!opts.video_id) {
        sendErrors.push('quickSendVideo Error: no video_id defined.');
    }

    // TODO: should we attempt to send without specifying any email addresses?
    if (!opts.email_addresses) {
        sendErrors.push('quickSendVideo Error: no email_address defined.');
    }

    if (sendErrors.length > 0 && !opts.video_id) {
        this.getVideoId(function (guid) {
            if (guid) {
                opts.video_id = guid;
                this.sendRequest(opts, onSuccess);
            }
            else {
                sendErrors.push('quickSendVideo: Terminal Error: Unable to set video_id');
                this.onError({info: {errmsg: sendErrors}});
            }
        });
    }
    else {
        this.sendRequest(opts, onSuccess);
    }

};

// returns the url for the embedded video recorder, typically used for iframes
/**
 *
 * @param {Object} [options]
 * @param {Function} onComplete
 */
BBCore.prototype.getEmbeddedRecorderUrl = function (options, onComplete) {
    if (typeof options === "function") {
        onComplete = options;
        options = {};
    }

    var defOpts = {height: 240, width: 320, force_ssl: false};
    if (typeof options.height === 'undefined') {
      options = {
        ...defOpts,
        ...options,
      }
    }

    var reqParams = {
      ...options,
      module: 'videos',
      page: 'EmbeddedRecorder',
      popup: 1,
      nohtml: 1
    };
    var inst = this;

    this.getVideoId(function (vidId) {
        var embeddedVideoRecorderUrl = inst.getServerUrl() + '/app/?',
            legacyToken = inst.getKey()
            // if a legacy token is set, but we don't want to trigger login functionality...
            ignoreLegacyToken = options.ignoreLegacyToken || false;
        if (legacyToken && legacyToken.length && !ignoreLegacyToken)
        {
            reqParams.api_key = legacyToken;
            embeddedVideoRecorderUrl += 'module=login&actn=login&api_key=' + legacyToken +
              '&redir=' + btoa(embeddedVideoRecorderUrl +
              Object.keys(reqParams).map(key => key + '=' + encodeURIComponent(reqParams[key])).join('&') +
              (vidId ? '&vguid=' + vidId : ''));
            onComplete.call(this, {url: embeddedVideoRecorderUrl, video_id: vidId});
        }
        else
        {
            options.videoId = vidId;
            this.getVideoRecorder(options, function(data){
                var recorderUrl = '';
                if (data && data.info && data.info.content.length)
                {
                    var recMatchUrl =  /https*:\/\/[^<"]+/.exec(data.info.content);
                    recorderUrl = recMatchUrl[0];
                }
                onComplete({ url: recorderUrl, video_id: vidId });
            });
        }
    });

};

/**
 *
 * @param {object} opts
 * @param {Function} onComplete
 */
BBCore.prototype.getVideoRecorder = function (opts, onComplete) {
    if (typeof opts === "function") {
        onComplete = opts;
        opts = null;
    }
    var defOpts = {height: 240, width: 320, force_ssl: false, start: null, stop: null, recorded: null};

    mergedOpts = {
      ...defOpts,
      ...opts
    };

    if (!this.isAuthenticated()) {
        this.onError({message: "Must authenticate session before invoking methods."});
        return;
    }
    mergedOpts.method = "GetVideoRecorder";

    // TODO; might be good to set the video id before passing to success execution
    // TODO; may need to inject the recorder event calls binding back to the API

    this.sendRequest(mergedOpts, function (response) {
        if (onComplete) {
            onComplete.call(this, response);
        }
    });

};

// TODO; COULD MERGE with getVideoRecorder if the default options included, stop, start, recorded parameters
BBCore.prototype.startVideoRecorder = function (opts, recordComplete) {
    if (typeof opts === "function") {
        recordComplete = opts;
        opts = null;
    }
    var defOpts = {
        type: 'embedded',
        target: null,
        height: 240,
        width: 320,
        force_ssl: false,
        recorderLoaded: null,
        recordComplete: recordComplete
    };

    opts = opts || defOpts;

    if (opts.recordComplete && !recordComplete) {
        recordComplete = opts.recordComplete;
    }

    if (opts.target) {
      this.__vidRecHndl =  document.querySelector(opts.target)
    } else {
      const elem = document.createElement('div');
      elem.id = 'b2recorder'
      this.__vidRecHndl = document.querySelector('body').appendChild(elem);
    }

    var rec_opts = { ...opts };
    delete rec_opts.type;
    delete rec_opts.target;
    delete rec_opts.recordComplete;
    delete rec_opts.recorderLoaded;

    var inst = this;
    // get recorder and inject into target
    this.getVideoRecorder(rec_opts, function (data) {
        inst.currentVideoId = data.info.vid_id;

        console.log('startVideoRecorder :' + inst.currentVideoId);
        // `getVideoRecorder` returns html and js in the form of a string. In the old version of BBCore,
        // script tags were handled by jquery (by use of the eval method). Since we don't want to rely
        // on jQuery or end up having double event listeners, we go with the jquery way of mounting this
        // js if the client already supplies jQuery, or hardcode it ourselves if jQuery isn't around.
        if (window.jQuery) {
            this.__vidRecHndl = opts.target ? jQuery(opts.target) : jQuery('body').append('<div id="b2recorder"></div>');
            inst.__vidRecHndl.html(data.info.content);
        } else {
          window.addEventListener('message', function(event) {
              if (~event.origin.indexOf('app.bombbomb.com')) {
                  if (event.data.action == 'reportVideoRecorded') {
                      window.reportVideoRecorded(event.data.flname, event.data.log);
                  } else if (event.data.action == 'iframeResize') {
                      var frame = document.getElementById(inst.currentVideoId);
                      var fw = parseInt(frame.clientWidth, 10) || parseInt(frame.width, 10);
                      var fsw = parseInt(frame.style.width, 10);

                      if (fw && fw > fsw || isNaN(fsw)) {
                          frame.style.height = (fw * event.data.ratio) + "px";
                      } else if (fsw) {
                          frame.style.height = (fsw * event.data.ratio) + "px";
                      }
                  }
              }
          });
          inst.__vidRecHndl.innerHTML = data.info.content;
        }

        if (opts.recorderLoaded) {
            opts.recorderLoaded.call(inst, data.info);
        }
    });

    // add the callbacks for the recorder to this instance calls.
    window.bbStreamStartRecord = function (strname, flname) {
        console.log('bbStreamStartRecord triggered');
        inst.liveStreamStartRecord.call(inst, strname, flname);
    };
    window.bbStreamStopRecord = function (strname) {
        console.log('bbStreamStopRecord triggered');
        inst.liveStreamStopRecord.call(inst, strname);
    };

    window.reportVideoRecorded = function (flname, log) {
        console.log('reportVideoRecorded triggered');
        recordComplete({videoId: inst.currentVideoId, filename: flname, log: log});
    };
};

BBCore.prototype.destroyVideoRecorder = function () {
    if (typeof this.__vidRecHndl !== 'undefined') {
        this.__vidRecHndl.remove();
    }
    window.bbStreamStartRecord = null;
    window.bbStreamStopRecord = null;
    window.reportVideoRecorded = null;
};

BBCore.prototype.liveStreamStartRecord = function (streamname, filename) {
    this.__vidRecording = true;
    this.sendRequest({method: 'liveStreamStartRecord', streamname: streamname, filename: filename});
};

BBCore.prototype.liveStreamStopRecord = function (streamname) {
    this.__vidRecording = false;
    this.sendRequest({method: 'liveStreamStopRecord', streamname: streamname});
};

/**
 *
 * @param {string} title
 * @param {string} videoId
 * @param {string} videoFilename
 * @param {Function} success
 */
BBCore.prototype.saveRecordedVideo = function (title, videoId, videoFilename, success) {
    var vidId = videoId || this.currentVideoId;
    var inst = this;
    this.sendRequest({
        method: 'VideoRecordedLive',
        title: title,
        filename: videoFilename,
        vid_id: vidId
    }, function (data) {
        success.call(inst, data);
    });
};

/**
 * @class videoOptions
 * @prop {string} vid_id
 */

/**
 *
 * @param {Object} options
 */
BBCore.prototype.saveRecording = function (options) {
    var pVals = options;
    if (!pVals.vid_id) {
        return;
    }
    this.sendRequest({method: "VideoRecordedLive"}, pVals, function () {
    });
};
